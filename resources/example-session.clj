;; ## cmp.core Namespace
;; Change to the `cmp.core` name space

(in-ns 'cmp.core)
;;`#namespace[cmp.core]`

;; A list of the functions available in `cmp.core`
;; is generated by:

(dir cmp.core)
;;`c-info`
;;`c-mon`
;;`c-reset`
;;`c-run`
;;`c-status`
;;`c-stop`
;;`c-suspend`
;;`check`
;;...
;;`workon!`

;; Clojures `doc`-function may be used to read the
;; functions documentation:

(doc c-info)

;; returning:

;; >`cmp.core/c-info`
;; >
;; >`([] [i] [mp-id i])`
;; >
;; > Returns a info map about the `i`th container of
;; > the mpd with the id `mp-id`.


;;## The reference definition mpd-ref.edn

;; On a fresh system try to
;; load and build the **reference** measurement
;; program definition called `ref`.
;; `ref` is stored in [edn format](https://github.com/edn-format/edn)
;; at [resources/mpd-ref.edn](../resources/mpd-ref.edn).
;; The function:

(m-build-edn)

;; **build**s the mpd(s) defined in the cmp
;; configuration file [resources/config.edn](../resources/config.edn)
;; (see  keyword `:edn-mpds`). The build process embeds the data
;; structure in a fast key-value-store **kvs** (here [redis](https://redis.io)).
;; This kvs is called **short term memory (stm)**.

;; The kvs may be inspected  by graphical frontends
;; (see *redis gui* section of [cmp docu](https://wactbprot.github.io/cmp/))
;; by cli or by the function:

(st/key->keys "ref")

;; returning:
["ref@meta@descr"
 "ref@container@0@state@1@1"
 "ref@exchange@A"
 "ref@container@1@definition@0@0"
 "ref@definitions@1@definition@0@0"
 "ref@container@2@definition@0@0"
 "ref@definitions@2@definition@0@0"
 "ref@definitions@2@ctrl"
 "ref@container@0@definition@2@0"
 "ref@definitions@0@definition@0@0"
 "ref@definitions@0@descr"
 "ref@container@3@state@0@0"
 "ref@definitions@2@class"
 "ref@container@0@definition@0@0"
 "ref@container@0@state@0@0"
 "..."]

(st/key->val "ref@definitions@0@cond@0")

;; returning:
{:ExchangePath "A.Unit", :Methode "eq", :Value "Pa"}

(st/pat->keys "ref@container@0@state*")

;; returning:
["ref@container@0@state@1@1"
 "ref@container@0@state@0@0"
 "ref@container@0@state@2@0"
 "ref@container@0@state@1@2"
 "ref@container@0@state@1@0"
 "ref@container@0@state@1@3"
 "ref@container@0@state@0@1"]

;;## Set the definition to work on

;; Most api functions in the `cmp.core` namespace
;; need the `id` of the mpd to work on.

;; After
(workon! "ref")

;; the command
(c-info "ref" 1)

;; is the same as
(c-info 1)

;; `(workon! "ref")` stores the `mp-id` argument in
;; an `atom` called `current-mp-id`

(deref current-mp-id)
"ref"

;; With a defined `current-mp-id`, the  `mp-id` argument
;; may be skiped for most of the `cmp.core` functions.

(m-info)

;; returns:
{:mp-id "ref"
 :mp-descr "Simple measurement programm definition (mpd) ..."
 :mp-std "NN"
 :mp-ncont 7
 :mp-ndefins 3}

;;## Build the tasks
;;
;; The mpd building block is the **task**. Tasks are stored in the stm too.
;; This means that
;; they can be modified during runtime (a desperately
;; needed but missing [ssmp](https://github.com/wactbprot/ssmp)-feature) 
;; Simply run

(t-refresh)
(count (st/pat->keys "tasks*"))
;; result at the moment:
229

(st/key->val (first (st/pat->keys "tasks*")))
;; returns:
{:TaskName "SE1_ATMION-degas",
 :Action "TCP",
 :Host "%host",
 :Port "%port",
 :Values {:on "SDG1, 1%CR", :off "SDG1, 0%CR"},
 :Defaults {:%host "e75437", :%port "5302", :%CR "\r"}}


;; ------------8<----------------------

;;
;;`(t-table)` overview of all tasks loaded in short term memory.
;;The table may be filtered:

(t-table)

(t-table :Action "TCP")

;;
;;
;;
;;## start mpd
;;
;;```clojure
;;(workon! "ref")
;;(m-start)
;;```
;;
;;## run container
;;
;;Run the first *container* with:
;;
;;```clojure
;;(c-run 0)
;;;; same as:
;;(ctrl 0 "run")
;;```
;;
;;## go on
;;
;;Use the build-in `(doc x)` function (e.g. `(doc t-build)`) for further
;;details.
;;
;;```clojure
;;(doc t-build)
;;-------------------------
;;cmp.core/t-build
;;([])
;;  Builds the `tasks` endpoint. At
;;  runtime all `tasks` are provided by
;;  `st-mem`
;;```
;;
;;Use the build-in `(dir cmp.core)` function to get a list of all
;;functions in this namespace.
;;
;;## documents
;;
;;To add or rm documents for storing data in use `(d-add mp-id doc-id)`,
;;`(d-rm mp-id doc-id)`.  If `(->mp-id)` is set (by `(workon mp-id)`)
;;`(d-add doc-id)`, `(d-rm doc-id)` is sufficient.
;;
;;```clojure
;;(d-add "cal-2020-se3-kk-11111_0002")
;;;; hiob DEBUG [cmp.lt-mem:14] - try to get document
;;;;             with id: cal-2020-se3-kk-11111_0002
;;;; "OK"
;;(d-ids)
;;;; (cal-2020-se3-kk-11111_0001 cal-2020-se3-kk-11111_0002)
;;```
;;
